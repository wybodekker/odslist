#!/usr/bin/env ruby

# encoding: utf-8
# todo: make options:
# 	-r,--rows=list
#	-c,--cols=list

Version='1.07'
Myname = File.basename($0)

require 'optparse'
require 'colorize'
require 'ostruct'
gem 'ods', '>=0.1.4' 
require 'ods'
require 'erb'

Help=
<<'DOC'
= odslist - List the contents of an OpenDocument Spreadsheet
= Synopsis
words [options] files	

== Options
   
    --sheets=LIST  List the sheets in the comma separated |LIST|.
		   By default, all sheets are listed.
		   The list may contain sheet numbers (counting from 1 up)
		   or sheet names; if the list contains numbers only, all values
		   are considered to be numbers; otherwise, all are seen as names.
-c, --caption=STR  set caption to STR.
-l, --label=STR	   set label to STR.
-f, --format=STR   output format, one of:
			csv
			tabs
			tabular
			tabularx
			tabulary
			ctable
			longtable
			longtablex
-s, --specs=STR	   column specs, space separated,
		   last one repeated as needed.
		   default: L for tabulary, else X, if possible, else l.
-a, --article	   create compilable article document.
-r, --rotate	   rotate the paper to landscap.
-t, --thinrules	   separate rows with thin rules.
-V, --version	   print version and exit.
-h		   print this help and exit.
-H, --help	   show full documentation (use less!) and exit.


= Description
odslist lists the contents of an OpenDocument Spreadsheet in one of
several formats.

= Author
[Wybo Dekker](wybo@dekkerdocumenten.nl)

= Copyright
Released under the [GNU General Public License](www.gnu.org/copyleft/gpl.html)
DOC

def die(*m) mess :red,*m; exit 1; end
def Warn(*m) mess :magenta,*m; end
def mess(color,*m)
   name = Myname + ': '
   m.each do |v|
      STDERR.puts "#{name}#{v}".__send__(color)
      name.gsub!(/./,' ')
   end
end

def help
  system("echo \"#{Help}\" | less -P#{Myname}-#{Version.tr('.','Â·')}")
end

class Array
  def rep(sep)
    m = self.inject(0) {|i,v| i=[i,v.to_s.scan(sep).count].max }
    return (0..m).map { |i|
      self.map {|c| c.to_s.split(sep)[i] }
    }
  end
end

# test correctness of specs and extend to no. of columns
def testspecs(s,ok,ncol)
  # s: specs string to be tested
  # ok: allowed specs
  # ncol: no. of columns that need to be specified
  return if ok.empty?           # tabs and csv formats need no specs
  re = /([pm]{[^}]*})|[CJLRXYclr]/ # match col spec 

  t,nnow,i = s.dup,0,0
  while m = t.match(re)
    m = m[0]		# m is the matching substring, like c or p{3cm}
    i = t.index(re)	# i is the position of m in s
    nnow += 1		# counting how many columns have specifier in s
    t.sub!(re,' '*m.size)	# replace substring with spaces
    slast = m		# last matching string
    ilast = i		# and its position in s
  end
  n = ncol - nnow		# we need to add this many column specifiers
  if n > 0
    return "%s*{%d}{%s}%s" % [
      s.slice(0...ilast),
      n+1,
      slast,
      s.slice(ilast+slast.size..-1)
    ]
  elsif n == 0
    return s
  else
    Warn "too many (#{nnow}) column specifiers in #{s} for #{ncol} columns"
  end
end

legalspecs = {
         'csv' => '',
        'tabs' => '',
     'tabular' => 'clr',
    'tabularx' => 'Xclr',
    'tabulary' => 'CJLRXYclr',
      'ctable' => 'Xclr',
   'longtable' => 'clr',
  'longtablex' => 'Xclr',
}
defaultspecs = {
     'tabular' => 'l',
    'tabularx' => 'X',
    'tabulary' => 'L',
      'ctable' => 'X',
   'longtable' => 'l',
  'longtablex' => 'X',
}

formats={}
eval "formats = { #{DATA.read} }"
preamble = formats.delete('preamble')
postamble = formats.delete('postamble')

# Option defaults
 mysheets = []
  article = false
   format = 'tabs'
thinrules = false
   rotate = false
  caption = nil
    label = nil
    specs = nil

# These are used in ERB only
[nr=0,nc=0,format,caption,label,rotate,thinrules,article].each do |v|
   # do nothing, just fool the syntax check
end

OptionParser.new(
  banner = <<~EOD,
	#{Myname} - List contents of OpenDocument spreadsheet\n
	Usage: #{Myname} [options] file\n
	Options:
	EOD
   width = 18,
  indent = ''
) do |opts|
 
   opts.on(     '--sheets=list',String,
	'List the sheets in the comma separated |list|.',
	'By default, all sheets are listed',
        'The list may contain sheet numbers (counting from 1 up)',
        'or sheet names; if the list contains numbers only, all values',
        'are considered to be numbers; otherwise, all are seen as names'

   ) do |v|
      mysheets = v.split(',')
   end

   opts.on('-c','--caption=STR',String,
      'set caption to STR'
   ) do |v|
      caption = v
   end

   opts.on('-l','--label=STR',String,
      'set label to STR'
   ) do |v|
      label = v
   end

   opts.on('-f','--format=STR',String,
      "output format, one of:",
      "\t#{formats.keys.join("\n\t\t\t")}"
   ) do |v|
      format = v
   end

   opts.on('-s','--specs=STR',String,
      'column specs, space separated,',
      'last one repeated as needed',
      'default: C for tabulary, else X, if possible, else c'
   ) do |v|
       specs = v
   end

   opts.on('-a','--article',
      'create compilable article document'
   ) do
      article = true
   end

   opts.on('-r','--rotate',
      'rotate the paper to landscape'
   ) do
      rotate = true
   end

   opts.on('-t','--thinrules',
      'separate rows with thin rules'
   ) do
      thinrules = true
   end

   opts.on('-V','--version',
	'print version and exit'
   ) do
      puts Version
      exit
   end

   opts.on('-h',
	'print this help and exit'
   ) do
      puts opts.to_s.sub(/^ *-I\n/,'')
      exit
   end

   opts.on('-H','--help',
	'show full documentation (use less!) and exit'
   ) do
      help
      exit
   end

   opts.on('-I') do
      system("instscript #{Myname}")
      exit 0
   end

   opts.parse!
end

file = ARGV[0] or die "I need an .ods file"
file = file.sub(/\.ods$/,'')+'.ods'
File.exist?(file) or die "File #{file} does not exist"
File.empty?(file) and die "File #{file} is empty"

allsheets = Ods::File.new(file).sheets	# all available sheets
ns = allsheets.size			# no of available sheets
allnames = allsheets.inject([]) {|a,v| a.push(v.name)}	# their names

# Check if the requested sheets exist
# Create an array list with sheet numbers to print
list = mysheets		# sheet numbers or names we want to list
list.map! do |v|		# scan the entries
   i = allnames.index(v)	# is it the name of one of the sheets?
   if i				# if so
      v = i			# use that sheet
   else
      if v =~ /^[1-9][0-9]*$/	# is it a number starting at 1?
         v = v.to_i
         v.between?(1,ns) or die "There are only #{ns} sheets",
				 "and there is no sheet named #{v}"
         v -= 1
      else
         die "There is no sheet named #{v}"
      end
   end
end
# If the list appears to be empty, set it to all sheets:
list = (0...ns).to_a if list.empty?

specs ||= defaultspecs[format]

puts ERB.new(preamble, trim_mode:'%').result(binding) if specs
list.each do |i|
   s=allsheets[i]
   nr = s.nrow
   nc = s.ncol
   sp = testspecs(specs,legalspecs[format]||'',nc)
   puts ERB.new(formats[format], trim_mode:'%').result(binding)
end
puts ERB.new(postamble, trim_mode:'%').result(binding) if specs

__END__
'preamble' => <<~'EOD',
	% if article
	\documentclass[english]{article}
	\usepackage{ucs}\usepackage[utf8x]{inputenc}
	\usepackage[a4paper<%= rotate ? ',landscape' : '' %>,margin=20mm,noheadfoot]{geometry}
	% unless ['tabs','ctable','tabularx','tabular'].index(format)
	\usepackage{<%= format %>}
	% end
	\usepackage{babel,ctable}
	\def\Tbl#1{\begin{tabular}[t]{@{}l@{}}#1\end{tabular}}
	\def\H#1{\hsize=#1\hsize\raggedright}
	\pagestyle{empty}
	\begin{document}
	% end
	EOD
'postamble' => <<~'EOD',
	% if article
	\end{document}
	% end
	EOD
'csv' => <<~'EOD',
	# ==> Sheet: <%= s.name %>
	% s.data.each do |r|
	%   r.map! {|v| v=v.to_s; v='"'+v+'"' if v =~ /,/; v }
	<%= r.join(',') %>
	% end
	EOD
'tabs' => <<~'EOD',
	# ==> Sheet: <%= s.name %>
	% s.unmult.each do |r|
	<%= r.join("\t") %>
	% end
	EOD
'tabular' => <<~'EOD',
	%%==> Sheet: <%= s.name %>
	% if caption
	\centering{<%= caption %>}\\[1ex]
	% end
	% if label
	\label{<%= label %>}
	% end
	\begin{tabular}{<%= sp %>}
	  \FL
	% sep='\ML'; i=1; s.data.each do |r|
	    <%= r.map { |x| x=~/\|/ ? "\\Tbl{"+x.gsub(/\|/,'\\\\\\\\')+"}" : x}.join("\n  & ") %>
	  <%= sep %>
	% sep = (i+=1)==nr ? '\LL' : thinrules ? '\ML[.1pt]' : '\NN'
	% end
	\end{tabular}
	<%= article ? '\clearpage' : '' %>
	EOD
'tabularx' => <<~'EOD',
	%%==> Sheet: <%= s.name %> <%= nr %> rows, <%= nc %> columns =======
	% if caption
	\centering{<%= caption %>}\\[1ex]
	% end
	% if label
	\label{<%= label %>}
	% end
	\begin{tabularx}{\textwidth}{<%= sp %>}
	  \FL
	% sep='\ML'; i=1; s.data.each do |r|
	    <%= r.map { |x| x=~/\|/ ? "\\Tbl{"+x.gsub(/\|/,'\\\\\\\\')+"}" : x}.join("\n  & ") %>
	  <%= sep %>
	% sep = (i+=1)==nr ? '\LL' : thinrules ? '\ML[.1pt]' : '\NN'
	% end
	\end{tabularx}
	<%= article ? '\clearpage' : '' %>
	EOD

'tabulary' => <<~'EOD',
	%%==> Sheet: <%= s.name %> <%= nr %> rows, <%= nc %> columns =======
	% if caption
	\centering{<%= caption %>}\\[1ex]
	% end
	% if label
	\label{<%= label %>}
	% end
	\begin{tabulary}{\textwidth}{<%= sp %>}
	  \FL
	% sep='\ML'; i=1; s.data.each do |r|
	    <%= r.map { |x| x=~/\|/ ? "\\Tbl{"+x.gsub(/\|/,'\\\\\\\\')+"}" : x}.join("\n  & ") %>
	  <%= sep %>
	% sep = (i+=1)==nr ? '\LL' : thinrules ? '\ML[.1pt]' : '\NN'
	% end
	\end{tabulary}
	<%= article ? '\clearpage' : '' %>
	EOD

'ctable' => <<~'EOD',
	%%==> Sheet: <%= s.name %> <%= nr %> rows, <%= nc %> columns =======
	\ctable[
	% if caption
	  caption={<%= caption %>},
	% end
	% if label
	    label={<%= label %>},
	% end
	% if sp =~ /X/
	    width=\textwidth
	% end
	]{<%= sp %>}{}{
	  \FL
	% sep='\ML'; i=1; s.data.each do |r|
	    <%= r.map { |x| x=~/\|/ ? "\\Tbl{"+x.gsub(/\|/,'\\\\\\\\')+"}" : x}.join("\n    & ") %>
	  <%= sep %>
	% sep = (i+=1)==nr ? '\LL' : thinrules ? '\ML[.1pt]' : '\NN'
	% end
	}
	<%= article ? '\clearpage' : '' %>
	EOD

'longtable' => <<~'EOD',
	%%==> Sheet: <%= s.name %> <%= nr %> rows, <%= nc %> columns =======
	\begin{longtable}[l]{<%= sp %>}
	% if caption 
	     \caption{<%= caption %>
	% end
	% if label 
	     \label{<%= label %>}}
	% end
	  \ML\endfirsthead
	  \caption*{<%= caption %> (continued)}
	  \ML\endhead
	% sep='\ML'; i=1; s.data.each do |r|
	    <%= r.map { |x| x=~/\|/ ? "\\Tbl{"+x.gsub(/\|/,'\\\\\\\\')+"}" : x}.join("\n  & ") %>
	  <%= sep %>
	% sep = (i+=1)==nr ? '\LL' : thinrules ? '\ML[.1pt]' : '\NN'
	% end
	\end{longtable}
	<%= article ? '\clearpage' : '' %>
	EOD

'longtablex' => <<~'EOD',
	%%==> Sheet: <%= s.name %> <%= nr %> rows, <%= nc %> columns =======
	%%\keepXColumns % uncomment to spread table over full width
	\begin{longtablex}{\textwidth}[l]{<%= sp %>}
	% if caption 
	     \caption{<%= caption %>
	% end
	% if label 
	     \label{<%= label %>}}
	% end
	  \ML\endfirsthead
	  \caption*{<%= caption %> (continued)}
	  \ML\endhead
	% sep='\ML'; i=1; s.data.each do |r|
	    <%= r.map { |x| x=~/\|/ ? "\\Tbl{"+x.gsub(/\|/,'\\\\\\\\')+"}" : x}.join("\n  & ") %>
	  <%= sep %>
	% sep = (i+=1)==nr ? '\LL' : thinrules ? '\ML[.1pt]' : '\NN'
	% end
	\end{longtablex}
	<%= article ? '\clearpage' : '' %>
	EOD

